---
title: "SetophagaExercise"
author: "Ron R Togunov, Philip Mostert, Bob O'Hara"
date: "`r Sys.Date()`"
bibliography: '`r system.file("References.bib", package="PointedSDMs")`'
biblio-style: authoryear
format: html
---

# Introduction

Multi-species integrated SDM (iSDM), by default, shares the range, standard deviation, and precision parameters across species. Including multiple species in the model can improve the estimation and correction for sampling bias.

This exercise aims to set up your first integrated distribution model. By the end, you should know the steps to take to do this. We will use three datasets containing three *Setophaga* species collected around Pennsylvania state (USA). We will walk through a model for one species, and then you can try it for another species.

# *Setophaga* Example

This example aims to predict the distribution of three *Setophaga* species across Pennsylvania state. It has been used in seminal papers by Isaac et al. (2020) and Miller et al. (2019). This file extends the example by adding datasets for two additional species.

We will start by modeling the Black-throated blue warbler, *Setophaga caerulescens*, using the following data:
- A map of Pennsylvania
- eBird: Citizen Science data
- BBS: North American Breeding Bird Survey data
- BBA: Pennsylvania Breeding Bird Atlas
- Elevation: Height above sea level
- Canopy: Canopy cover (a proxy for forest)

## Model Preparations

The first step in our analysis is to load the required packages.

```{r Load packages, echo = F, warning = F, message = F}
## Load required packages
library(PointedSDMs) #devtools::install_github('PhilipMostert/PointedSDMs@main')
library(INLA)
library(inlabru)
library(USAboundaries) # remotes::install_version("USAboundaries", version = "0.3.0", repos = "http://cran.us.r-project.org")
library(sf)
library(blockCV)
library(ggmap)
library(sn)
library(terra)
library(RColorBrewer)
library(cowplot)
library(knitr)
library(kableExtra)
library(dplyr)
library(spocc)
library(here)
```
## Data Preparation

We need to organize the data into a single object to align the different data types. The `startISDM()` function does this.

```{r Map of PA}
## Define the projection system and create a polygon object for Pennsylvania
proj <- "+proj=utm +zone=17 +datum=WGS84 +units=km"
PA <- USAboundaries::us_states(states = "Pennsylvania")
PA <- st_transform(PA, proj)

```
Next, we load the species occurrence data and covariate data:

```{r GetData}
## Load the species occurrence data
SetohagaData <- readRDS(here("Data/Vignette_setophaga/SetophagaData.rds"))

## Load covariate data
covariates <- scale(terra::rast(system.file('extdata/SetophagaCovariates.tif', 
                                            package = "PointedSDMs")))
names(covariates) <- c('elevation', 'canopy')
```

The mesh is crucial as our model is a continuous surface approximated with a tessellation of triangles.

```{r Mesh}
#| warning: false
#| message: false
mesh <- inla.mesh.2d(boundary = inla.sp2segment(PA), 
                     cutoff = 10 * 5,
                     max.edge = c(1, 1.24) * 40, #120
                     offset = c(0.05, 0.4) * 100,
                     crs = st_crs(proj))
```


## Visualizing Covariate Interpolation

We plot the interpolated elevation and canopy values to check how well the mesh reflects the covariates:

```{r}
library(geometry)
library(Matrix)
library(patchwork)
library(tidyterra)

# project covs to project proj
covs <- project(aggregate(covariates,8,na.rm=TRUE), proj)  
# Extract mesh vertices
vertices <- as.data.frame(mesh$loc[, 1:2])
colnames(vertices) <- c("x", "y")
# Assuming your covariates are stored in a SpatRaster object named `covariates`
elevation_values <- terra::extract(covs[["elevation"]], vertices)
canopy_values <- terra::extract(covs[["canopy"]], vertices)

# Combine the vertex coordinates with the extracted values
vertices$elevation <- elevation_values[, 2]
vertices$canopy <- canopy_values[, 2]
# Convert vertices to an sf object
vertices_sf <- st_as_sf(vertices, coords = c("x", "y"), crs = st_crs(covariates))

# Get the triangles of the mesh
triangles <- mesh$graph$tv


# Create a grid of points over the study area for interpolation
ext <- terra::ext(covs)
centers <- expand.grid(seq(ext[1], ext[2],length.out= 200),seq(ext[3], ext[4],length.out= 100)) 
names(centers) <- c('x','y')
# Convert to data.frame
centers_df <- as.data.frame(centers)
# Convert to sf object
study_area <- st_as_sf(centers_df, coords = c("x", "y"), crs = crs(covs)) %>% 
  # remove points outside of shape
  st_crop(PA)
grid_points <- st_coordinates(study_area) 

# replace NAs
vertices$elevation[is.na(vertices$elevation)] <- 0
vertices$canopy[is.na(vertices$canopy)] <- 0

##2D barycentric interpolation at points Xi for a function with values f measured at locations X
#For N-D interpolation simply replace tsearch with tsearchn and modify the sparse matrix definition to have non-zero values in the right spots.
interp.barycentric <- function(X,f,Xi){
  dn <- delaunayn(X)
  tri <- tsearch(X[,1],X[,2],dn,Xi[,1],Xi[,2],bary=T)
  #For each line in Xi, defines which points in X contribute to the interpolation
  active <- dn[tri$idx,]
  # Filter out NAs from tri$idx and active
  valid_idx <- is.na(tri$idx)
  active[valid_idx, ] <- 1
  tri$p[valid_idx, ] <- 1
  
  # Define the interpolation as a sparse matrix operation
  M <- sparseMatrix(i = rep(1:nrow(Xi), each = 3), j = as.numeric(t(active)), x = as.numeric(t(tri$p)), dims = c(nrow(Xi), length(f)))
  as.numeric(M %*% f)
}

# Interpolate elevation values
interpolated_elevation <- interp.barycentric(as.matrix(vertices[, c("x", "y")]), vertices$elevation, grid_points)

# Interpolate canopy values
interpolated_canopy <- interp.barycentric(as.matrix(vertices[, c("x", "y")]), vertices$canopy, grid_points)

# Combine the interpolated points with the values
interpolated_df <- data.frame(
  x = grid_points[, 1],
  y = grid_points[, 2],
  elevation = interpolated_elevation,
  canopy = interpolated_canopy
)

# Convert to sf object
interpolated_sf <- st_as_sf(interpolated_df, coords = c("x", "y"), crs = st_crs(covariates))


# Plot interpolated elevation with regular tiles
p1 <- ggplot(interpolated_df) +
  geom_tile(aes(x = x, y = y, fill = elevation)) +
  labs(title = "Interpolated Elevation", fill = "Elevation")
p1b <- ggplot() + geom_spatraster(data = covs$elevation)
# Plot interpolated canopy with regular tiles
p2 <- ggplot(interpolated_df) +
  geom_tile(aes(x = x, y = y, fill = canopy)) +
  labs(title = "Interpolated Canopy", fill = "Canopy")
p2b <- ggplot() + geom_spatraster(data = covs$canopy)

# Display plots side by side
p1b + p1 + 
  p2b + p2 & 
  scale_fill_viridis_c() 

```


## Running the Model 

Now we have our data, we need to organise it into a single object. This means we can do hing slike align the different data, e.g. so each data point has the right covariate data. The `startISDM()` function does this. This needs a few arguments, which we will discuss in more detail later.

The next function of interest is `startSpecies`, which is used to construct a multi-species ISDM. The argument `speciesName` is required, and it denotes the name of the species variable common across the datasets. Additional arguments include: `speciesSpatial` to control the type of spatial effect used for the species, `speciesIntercept` to control the intercept for the species and `speciesEnvironment` to control the environmental effects for the species (common across species or shared).

For this example, we use the default argument choices which include: a model with a spatial effect per species (with shared hyperparameters) and a random intercept term for the species. We remove the dataset specific spatial term for computational purposes by setting `pointsSpatial = NULL`.


```{r startSpeciesStart}

speciesModel <- startSpecies(SetohagaData, Boundary = PA, 
                             Projection = proj, Mesh = mesh,
                             responsePA = 'NPres', 
                             # responseCounts = 'Counts',
                             trialsPA = 'Trials', # Name of no. of trials for binomial data
                             speciesSpatial = "replicate",  # unique spatial field per species 
                             pointsSpatial = NULL,  # no dataset spatial field
                             spatialCovariates = covariates, 
                             speciesName = 'Species_name')

```

Again, the output of this function is an *R6* object, and additional documentation from the function be be obtained using `?.$help()`.

```{r species help, eval = FALSE}

speciesModel$help()

```

Plotting the multi-species model, shows the distribution by species rather than by dataset as in the previous vignette.

```{r dataset plot}
#| fig.width: 8 
#| fig.height: 5
speciesModel$plot() +
  theme_bw() +
  ggtitle('Plot of the species') + 
  theme(plot.title = element_text(hjust = 0.5))
```

###### Specifying the model

Like the single-species model provided above, we specify the priors for the fixed and random effects using `.$specifySpatial` , `.$priorsFixed` and `.$specifyRandom`. In `.$specifyRandom`, the argument `speciesGroup` is used to change the prior for the precision (inverse variance) of group model for the spatial effects, and `speciesIntercepts` is used to change the prior for the precision for the random intercept term. For both of these parameters, we choose *pc priors.*

Specify priors for spatial and random effects

```{r specifySpecies}
# hyper parameters of the spatial field (shared across species)
speciesModel$specifySpatial(Species = TRUE,  # define same prior for the all species
                            prior.sigma = c(1, 0.1),  # SD of field variation; P(σ > σ0)
                            prior.range = c(15, 0.1))  # range of spatial correlation; P(ρ < ρ0)

# prior for intercept of datasets (common for all datasets and all species in the model)
speciesModel$priorsFixed(Effect = 'Intercept',
                         mean.linear = 0, 
                         prec.linear = 0.1)

# prior for random effects (mesh nodes of spatial field and species intercepts)
speciesModel$specifyRandom(
  # precision parameter on how much each species' spatial field (how much they can deviate from the shared ___)
  speciesGroup = list(model = "iid", 
                      hyper = list(prec = list(prior = "pc.prec",
                                               param = c(0.1, 0.1)))),  # P(σ > σ0)
  # precision parameter on the baseline species occurrence rate
  speciesIntercepts = list(prior = 'pc.prec',
                           param = c(0.1, 0.1)))  # P(σ > σ0)

```


Now we can fit the model:

We may then estimate the model using `fitISDM`.

```{r fitSpecies}
modelOptions <- list(control.inla = list(int.strategy = 'eb', diagonal = 0.1), 
                     verbose = FALSE, safe = TRUE)

speciesEst <- fitISDM(data = speciesModel, 
                      options = modelOptions)


```

###### Predicting and plotting


```{r}

summary(speciesEst)

```

Predictions and plotting are completed as follows:

```{r predictionsSpecies}

speciesPredictions <- predict(speciesEst,
                              data = fm_pixels(mesh = mesh,
                                               mask = PA),
                              spatial = TRUE,
                              n.samples = 100)

plot(speciesPredictions)

```

```{r predictionsSpecies2}

speciesPredictions2 <- predict(speciesEst,
                               data = fm_pixels(mesh = mesh,
                                                mask = PA),
                               spatial = TRUE,
                               covariates = speciesEst$spatCovs$name,
                               n.samples = 100)
plot(speciesPredictions2)

```

```{r predictionsSpecies3}

speciesPredictions3 <- predict(speciesEst,
                               data = fm_pixels(mesh = mesh,
                                                mask = PA),
                               spatial = FALSE,
                               covariates = speciesEst$spatCovs$name,
                               n.samples = 100)
plot(speciesPredictions3)

```


```{r}
speciesPredictions %>% class
speciesPredictions %>% length
speciesPredictions %>% names
speciesPredictions[[1]] %>% class
speciesPredictions[[1]] %>% length
speciesPredictions[[1]] %>% names
speciesPredictions[[1]][[1]] %>% class
speciesPredictions[[1]][[1]] %>% length
speciesPredictions[[1]][[1]] %>% names
speciesPredictions[[1]][[1]] %>% head

```

```{r}
speciesEst$summary.fixed
```



